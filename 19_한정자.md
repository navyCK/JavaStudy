## 한정자
클래스, 변수, 생성자, 메소드 앞에 붙어 각각의 접근, 기능을 제어하는 역할

```java
public static void main(String args[]) { ... }
// 왜 이렇게 사용하는가?
```
## static
공통적으로 프로그램 시작과 동시에 메모리에 올린다. (load시 메모리 할당)

main 메소드 앞에 붙은 이유는 프로그램 실행 시 cpu는 오직 메모리와 대화하기 때문에,

프로그램의 시작 부분이 당연히 메모리에 로드되어 있어야 하기 때문.

- 클래스, 생성자 앞 : 사용 불가
- 멤버 변수 : 객체 생성 시 각자 자신만의 멤버 변수를 갖는데, static이 붙으면 각자 해당하는 변수를 갖지 못하고 서로 공유하는 공통 변수를 갖게 되고, 변수 접근도 객체가 아닌 클래스로 가능하다.
- 메소드 : 멤버 변수와 마찬가지로 객체가 아닌 클래스로도 접근 가능, 객체를 생성하지 않아도 자주 사용되는 메소드라면 static으로 사용됨.

## synchronized
동기화를 의미, 여러 객체가 한번에 사용되면 안되고 순차적으로 사용되야 하는 경우 사용된다.

- 클래스, 멤버변수, 생성자 : 사용 불가
- 메소드 : 멤버 변수와 마찬가지로 객체가 아닌 클래스로 접근 가능. 메소드라면 static으로 사용하곤 한다.

정리하자면 synchronized 함수는 자신이 포함된 객체에 lock을 겁니다.

따라서 동기화 문제를 해결하는데 가장 간단하고 확실하면서 무식한 방법입니다.

여기서 무식하다 함은 synchronized로 인하여 객체에 포함된 다른 모든 synchronized의 접근 까지 lock이 걸리기 때문입니다.

그래서 synchronized block이 존재합니다.^^

이제 블록 사용법을 보시죠~


## final 

끝을 의미

- 클래스 : 상속이 불가능해진다.
- 멤버 / 일반 변수 : 그 변수는 더이상 수정 불가능 => 즉 변할 수 있는 변수가 아닌 상수
- 생성자 : 사용 불가
- 메소드 : 오버라이딩 불가능, 상속과 관련된 내용.


## 한정자

### abstract : 추상적 상태 의미

내용은 없고, 추상적인 오버라이딩

- 클래스 : 추상 처리
- 멤버 변수, 생성자 : 사용 불가
- 메소드 : 추상 클래스 외 사용 불가. 사용 시 메서드 선언 외에 바디를 가질 수 없다.


## 접근 제어자
특정 데이터에 아무나 접근을 허용해서는 안된다.

1. 프로그램 (프로젝트)
2. 패키지 (폴더)
3. 클래스


### public
